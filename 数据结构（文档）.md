# 线性结构（栈和队列）
## 栈
1. 定义：一种遵从先进后出（LIFO/Last In First Out）原则的有序集合，新添加的或待添加的元素都保存在栈的末尾，成为栈顶，另一端为栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底

2. 操作：
    * push(element): 添加一个新元素到栈顶位置
    * pop(): 移除栈顶的元素，同时返回被移除的元素
    * peek(): 返回栈顶的元素，不对栈做出任何修改（这个方法不会移除栈顶元素，仅仅是返回这个元素）
    * isEmpty(): 如果栈里没有任何元素就返回true，否则返回false
    * clear(): 移除栈里的所有元素
    * size(): 返回栈里的元素个数。这个方法与数组中的length属性类似

## 队列
1. 定义：一种遵循先进先出（FIFO/First In First Out）原则一组有序的项，队列在队尾添加新元素，并从头部移除元素。最新添加的元素必须排在队列的末尾

2. 操作：
    * enqueue(element): 向队列尾部添加一个（或多个）新的项
    * dequeue(): 移除队列的第一（即排在队列最前面的）项，并返回被移除的元素
    * front(): 返回队列中第一个元素————最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息————与Stack类peek()方法类似）
    * isEmpty(): 如果队列中不包含任何元素，返回true，否则返回false
    * size(): 返回队列包含的元素个数，与数组的length属性类似

3. 优先级队列
    * 按照优先级进行比较，得到元素在队列中正确的位置
    * 实现优先级队列
        1. 封装元素和优先级放在一起（可以封装一个新的构造函数）
        2. 添加元素时，将当前的优先级和队列中已经存在的元素优先级进行比较，以便获取正确的位置

# 链表
* 重点
    1. 存储多个元素
    2. 链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（指针/链接）组成
    3. 内存空间不是必须连续的，可以充分利用计算机的内存，实现领过的内存动态管理
    4. 链表不必在创建时就确定大小，并且大小可以无限的延伸下去
    5. 链表在插入和删除数据时，时间复杂度可以达到 O(1)，相对于数组效率高很多
    6. 缺点：
        1. 链表访问任何一个位置的元素时，都需要从头开始访问（无法跳过第一个元素访问任何一个元素）
        2. 无法通过下标直接访问元素，需要从头一个个访问，直到找到对应的问题

## 单向链表
1. 单向链表
    1. 只能从头遍历到尾或者从尾遍历到头（一般从头到尾）也就是链表相连的过程是单向的，实现的原理是上一个链表中有一个指向下一个的引用
    2. 缺点：可以轻松的到下一个节点，但是回到前面一个节点很难。
    eg：假设一个文本编辑用链表来存储文本，每一行用一个String对象存储在链表的一个节点中，当编辑器用户向下移动光标时，链表直接操作到下一个节点即可；但是当用于将光标向上移动呢？这个时候为了回到上一个节点，我们可能需要从first开始，依次走到想要的节点上。
2. 操作：
    * append(element): 向列表尾部添加一个新的项
    * insert(position, element): 向列表的特定位置插入一个新的项
    * remove(element): 从列表中移除一项
    * indexOf(element): 返回元素在列表中的索引。如果列表中没有该元素，则返回-1
    * removeAt(position): 从列表的特定位置移除一项
    * isEmpty(): 如果链表中不包含任何元素，返回 true；如果链表的长度大于0，则返回 false
    * size(): 返回链表包含的元素个数（与数组的length属性类似）
    * toString(): 由于列表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值

## 双向链表
1. 双向链表
    1. 既可以从头遍历到尾，也可以从尾遍历到头。也就是链表相连的过程是双向的。
    2. 一个节点既有向前连接的引用，也有一个向后链接的引用
    3. 缺点：每次在插入或删除某个节点时，需要处理四个节点，而不是两个，操作困难。所占内存空间也要更大
2. 操作：
    * append(element)：在尾部追加数据
    * insert(position, element): 在任意位置插入数据
    * removeAt(position): 根据位置删除对应的元素
    * indexOf(element): 返回元素在列表中的索引。如果列表中没有该元素，则返回-1
    * remove(element): 从列表中移除一项
    * isEmpty(): 如果链表中不包含任何元素，返回 true；如果链表的长度大于0，则返回 false
    * size(): 返回链表包含的元素个数（与数组的length属性类似）
    * getHead()：获取第一个元素
    * getTail()：获取最后一个元素
    * 遍历方法的实现
        * forwardString()：正向遍历
        * reverseString()：反向遍历
    * toString(): 由于列表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值

# 集合
1. 集合通常是由一组无序的, 不能重复的元素构成。
    1. 和数学中的集合名词比较相似, 但是数学中的集合范围更大一些, 也允许集合中的元素重复.
    2. 在计算机中, 集合通常表示的结构中元素是不允许重复的.
2. 看成一种特殊的数组。
    1. 其实集合你可以将它看成一种特殊的数组.
    2. 特殊之处在于里面的元素没有顺序, 也不能重复.
    3. 没有顺序意味着不能通过下标值进行访问, 不能重复意味着相同的对象在集合中只会存在一份.
3. 操作
    * add(value)：向集合添加一个新的项。
    * remove(value)：从集合移除一个值。
    * has(value)：如果值在集合中，返回true，否则返回false。
    * clear()：移除集合中的所有项。
    * size()：返回集合所包含元素的数量。与数组的length属性类似。
    * values()：返回一个包含集合中所有值的数组。
