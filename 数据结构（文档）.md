# 线性结构（栈和队列）
## 栈
1. 定义：一种遵从先进后出（LIFO/Last In First Out）原则的有序集合，新添加的或待添加的元素都保存在栈的末尾，成为栈顶，另一端为栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底

2. 操作：
    * push(element): 添加一个新元素到栈顶位置
    * pop(): 移除栈顶的元素，同时返回被移除的元素
    * peek(): 返回栈顶的元素，不对栈做出任何修改（这个方法不会移除栈顶元素，仅仅是返回这个元素）
    * isEmpty(): 如果栈里没有任何元素就返回true，否则返回false
    * clear(): 移除栈里的所有元素
    * size(): 返回栈里的元素个数。这个方法与数组中的length属性类似

## 队列
1. 定义：一种遵循先进先出（FIFO/First In First Out）原则一组有序的项，队列在队尾添加新元素，并从头部移除元素。最新添加的元素必须排在队列的末尾

2. 操作：
    * enqueue(element): 向队列尾部添加一个（或多个）新的项
    * dequeue(): 移除队列的第一（即排在队列最前面的）项，并返回被移除的元素
    * front(): 返回队列中第一个元素————最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息————与Stack类peek()方法类似）
    * isEmpty(): 如果队列中不包含任何元素，返回true，否则返回false
    * size(): 返回队列包含的元素个数，与数组的length属性类似

3. 优先级队列
    * 按照优先级进行比较，得到元素在队列中正确的位置
    * 实现优先级队列
        1. 封装元素和优先级放在一起（可以封装一个新的构造函数）
        2. 添加元素时，将当前的优先级和队列中已经存在的元素优先级进行比较，以便获取正确的位置

# 链表
* 重点
    1. 存储多个元素
    2. 链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（指针/链接）组成
    3. 内存空间不是必须连续的，可以充分利用计算机的内存，实现领过的内存动态管理
    4. 链表不必在创建时就确定大小，并且大小可以无限的延伸下去
    5. 链表在插入和删除数据时，时间复杂度可以达到 O(1)，相对于数组效率高很多
    6. 缺点：
        1. 链表访问任何一个位置的元素时，都需要从头开始访问（无法跳过第一个元素访问任何一个元素）
        2. 无法通过下标直接访问元素，需要从头一个个访问，直到找到对应的问题

## 单向链表
1. 单向链表
    1. 只能从头遍历到尾或者从尾遍历到头（一般从头到尾）也就是链表相连的过程是单向的，实现的原理是上一个链表中有一个指向下一个的引用
    2. 缺点：可以轻松的到下一个节点，但是回到前面一个节点很难。
    eg：假设一个文本编辑用链表来存储文本，每一行用一个String对象存储在链表的一个节点中，当编辑器用户向下移动光标时，链表直接操作到下一个节点即可；但是当用于将光标向上移动呢？这个时候为了回到上一个节点，我们可能需要从first开始，依次走到想要的节点上。
2. 操作：
    * append(element): 向列表尾部添加一个新的项
    * insert(position, element): 向列表的特定位置插入一个新的项
    * remove(element): 从列表中移除一项
    * indexOf(element): 返回元素在列表中的索引。如果列表中没有该元素，则返回-1
    * removeAt(position): 从列表的特定位置移除一项
    * isEmpty(): 如果链表中不包含任何元素，返回 true；如果链表的长度大于0，则返回 false
    * size(): 返回链表包含的元素个数（与数组的length属性类似）
    * toString(): 由于列表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值

## 双向链表
1. 双向链表
    1. 既可以从头遍历到尾，也可以从尾遍历到头。也就是链表相连的过程是双向的。
    2. 一个节点既有向前连接的引用，也有一个向后链接的引用
    3. 缺点：每次在插入或删除某个节点时，需要处理四个节点，而不是两个，操作困难。所占内存空间也要更大
2. 操作：
    * append(element)：在尾部追加数据
    * insert(position, element): 在任意位置插入数据
    * removeAt(position): 根据位置删除对应的元素
    * indexOf(element): 返回元素在列表中的索引。如果列表中没有该元素，则返回-1
    * remove(element): 从列表中移除一项
    * isEmpty(): 如果链表中不包含任何元素，返回 true；如果链表的长度大于0，则返回 false
    * size(): 返回链表包含的元素个数（与数组的length属性类似）
    * getHead()：获取第一个元素
    * getTail()：获取最后一个元素
    * 遍历方法的实现
        * forwardString()：正向遍历
        * reverseString()：反向遍历
    * toString(): 由于列表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值

# 集合
1. 集合通常是由一组无序的, 不能重复的元素构成。
    1. 和数学中的集合名词比较相似, 但是数学中的集合范围更大一些, 也允许集合中的元素重复.
    2. 在计算机中, 集合通常表示的结构中元素是不允许重复的.
2. 看成一种特殊的数组。
    1. 其实集合你可以将它看成一种特殊的数组.
    2. 特殊之处在于里面的元素没有顺序, 也不能重复.
    3. 没有顺序意味着不能通过下标值进行访问, 不能重复意味着相同的对象在集合中只会存在一份.
3. 操作
    * add(value)：向集合添加一个新的项。
    * remove(value)：从集合移除一个值。
    * has(value)：如果值在集合中，返回 true，否则返回 false。
    * clear()：移除集合中的所有项。
    * size()：返回集合所包含元素的数量。与数组的 length 属性类似。
    * values()：返回一个包含集合中所有值的数组。

# 字典
1. 字典的特点：一一对应的关系
    * eg：比如保存一个人的信息，在合适的情况下取出这些信息
        1. 比如数组的方式：[18, "Evildoer98", 178]，可以通过下标值取出信息
        2. 使用字典的方式：{"age" : 18, "name" : "Evildoer98", "height" : 1.78}，可以通过 key 取出 value
2. 操作：
    * set(key,value)：向字典中添加新元素。
    * remove(key)：通过使用键值来从字典中移除键值对应的数据值。
    * has(key)：如果某个键值存在于这个字典中，则返回true，反之则返回false。
    * get(key)：通过键值查找特定的数值并返回。
    * clear()：将这个字典中的所有元素全部删除。
    * size()：返回字典所包含元素的数量。与数组的length属性类似。
    * keys()：将字典所包含的所有键名以数组形式返回。
    * values()：将字典所包含的所有数值以数组形式返回。

# 树
1. 树的定义：
    * 树(Tree)：n(n >= 0) 个结点构成的有限集合
        * 当 n = 0，称为空书
        * 对于任何一颗非空树(n > 0)，它具有以下性质
            1. 树中一个称为"根(root)"的特殊结点，用 r 表示
            2. 其余结点可分为 m (m > 0)个互不相交的有限集 T1,T2,...,Tm，其中每个集合本身又是一棵树，称为原来树的"子树(SubTree)"
    * 注意：
        * 子树之间不可以香蕉
        * 除了根节点外，每个结点有且仅有一个父结点
        * 一颗 N 个结点的树有 N-1 条边
2. 树的术语：
    1. 结点的度(Degree)：结点的子树个数
    2. 树的度：树的所有结点中最大的度数。(树的度通常为结点的个数 N - 1)
    3. 叶结点(Leaf)：度为 0 的结点。(也称为叶子结点)
    4. 父结点(Parent)：有子树的结点是其子树的根节点的父结点
    5. 子结点(Child)：若 A 结点是 B 结点的父结点，则称 B 结点是 A 结点的子节点；子结点也称为孩子结点
    6. 兄弟结点(Sibling)：具有同一父节点的各结点彼此是兄弟结点
    7. 路径和路径长度：从结点 n1 到 nk 的路径为一个结点序列 n1, n2,...,nk，ni 是 n(i+1) 的父结点。路径所包含边的个数为路径的长度
    8. 结点的层次(Level)：规定根结点在 1 层，其余任一结点的层数是其父结点的层数加 1
    9. 树的深度(Depth)：树中所有结点的最大层次就是这棵树的深度
 
# 二叉树
1. 二叉树的定义：
    * 二叉树可以为空，也就是没有结点
    * 若不为空，则它是由根结点和称为其左子树 TL 和右子树 TR 的两个不相交的二叉树组成
2. 二叉树的特征：
    * 一个二叉树第 i 层的最大结点数为：2^(i-1)，i >= 1
    * 深度为 k 的二叉树有最大结点总数为：2^k-1，k >= 1
    * 对任何非空二叉树 T，若 n0 表示叶结点的个数、n2 是度为 2 的非叶子结点个数，那么两者满足关系 n0 = n2 + 1

## 特殊的二叉树
1. 完美二叉树，也称为满二叉树
    * 在二叉树中，除了最下层的叶结点外，每层结点都有 2 个结点，就构成了满二叉树
2. 完全二叉树
    * 除二叉树最后一层外，其他各层的结点数都达到最大个数
    * 且最后一层从左到右的叶结点连续存在，只缺右侧若干结点

## 二叉树的存储
1. 二叉树的存储常见的方式是数组和链表
2. 使用数组存储：
    * 完全二叉树：按从上至下、从左到右顺序存储
    * 非完全二叉树：
        * 非完全二叉树要转成完全二叉树才可以按照上面的方案存储
        * 但是会造成很大的空间浪费
3. 链表存储：
    * 二叉树最常见的方式还是使用链表存储
    * 每个结点封装成一个 Node，Node 中包含存储的数据，左结点的引用，右结点的引用

# 二叉搜索树
1. 二叉搜索树（BST），也称二叉搜索树或二叉查找树
2. 二叉搜索树是一颗二叉树，可以为空；如果不为空，满足一下性质：
    * 非空左子树的所有键值小于其根结点的键值
    * 非空右子树的所有键值大于其根结点的键值
    * 左、右结点本身也都是二叉搜索树
3. 二叉搜索树的特点：
    * 二叉搜索树的特点就是相对较小的值总是保存在左节点上，相对较大的值总是保存在右结点上
    * 查找效率非常高
4. 操作：
    * insert(key)：向树中插入一个新的键。
    * search(key)：在树中查找一个键，如果结点存在，则返回true；如果不存在，则返回false。
    * inOrderTraverse：通过中序遍历方式遍历所有结点。
    * preOrderTraverse：通过先序遍历方式遍历所有结点。
    * postOrderTraverse：通过后序遍历方式遍历所有结点。
    * min：返回树中最小的值/键。
    * max：返回树中最大的值/键。
    * remove(key)：从树中移除某个键。

# 红黑树
1. 红黑树，除了符合二叉搜索树的基本规则外，还添加了一下特性：
    1. 结点是黑色或红色
    2. 根结点是黑色
    3. 每个叶子结点都是黑色的空结点（NIL结点）
    4. 每个红色结点的两个子结点都是黑色（从每个叶子到根的所有路径上不能有两个连续的红色结点）
    5. 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点
2. 前面的约束，确保了红黑树的关键特性：
    1. 从根到叶子的最长可能路径，不会超过最短可能路径的两倍长
    2. 结果就是这个树基本是平衡的
    3. 虽然没有做到绝对平衡，但是可以保证在最坏的情况下，依然是高效的
3. 为什么可以做到最长路径不超过最短路径的两倍呢？
    1. 性质4决定了路径不能有两个相连的红色结点
    2. 最短的可能路径都是黑色结点
    3. 最长的可能路径是红色和黑色交替
    4. 性质5所有路径都有相同数目的黑色结点
    * 这就表明了没有路径能多余任何其他路径的两倍长
* 变色
    * . 插入一个新结点时，有可能树不再平衡，可以通过三种方式的变换，让树保持拼很
        * 换色、坐旋转、右旋转
    * 变色：为了重新符合红黑树的规则，尝试把红色结点变成黑色，或者把黑色结点变为红色
    * 插入的新结点通常都是红色节点
        * 因为在插入结点为红色的时候，有可能插入一次是不违反红黑树任何规则的
        * 而插入黑色结点，必然会导致有一条路径多了黑色结点，导致难以调整
        * 红色结点可能导致出现红红相连的情况，但是这种情况可以通过颜色调换和旋转来调整
* 旋转
    * 左旋转
        * 逆时针旋转红黑树的两个结点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子
    * 右旋转
        * 顺时针旋转红黑树的两个结点，使得父结点被自己的左孩子取代，而自己成为右孩子

# 图
* 术语：
    1. 顶点：表示图中的一个结点
    2. 边：表示顶点和顶点之间的连线
    3. 相邻顶点：由一条边连接在一起的顶点称为相邻顶点
    4. 度：一个顶点的度是相邻顶点的数量
    5. 路径：
        * 简单路径：要求不包含重复的顶点
        * 回路：第一个顶点和最后一个顶点相同的路径称为回路
    6. 无向图：所有的边都没有方向
    7. 有向图：所有的边都是有方向的
    8. 无权图和带权图：
        * 无权图：边没有携带权重（边是没有任何意义的）
        * 带权图：边有一定的权重（边是任意表示的数据）
* 图的表示
    * 邻接矩阵
        1. 邻接矩阵让每个结点和一个整数向关联，该整数作为数组的下标值
        2. 用二维数组来表示顶点之间的连接
        * 问题：
            1. 如果是一个无向图，邻接矩阵展示出来的二维数组，其实是一个对称图
            2. 图是稀疏图：那么矩阵中将存在大量的 0，浪费存储空间；找边的时候必须遍历一行来找出这个边，费时间
    * 邻接表
        1. 邻接表由图中每个顶点以及和顶点相邻的顶点列表组成
        2. 这个列表有很多种方式来存储：数组/链表/字典（哈希表）
        * 问题：
            1. 邻接表计算“出度”是比较简单的（出度：指向别人的数量，入读：指向自己的数量）
            2. 邻接表如果需要计算有向图的“入度”，那么是一件非常麻烦的事情
            3. 它必须构造一个“逆邻接表”，才能有效的计算“入度”
* 图的遍历
    1. 图的遍历思想：在于必须访问每个第一次访问的结点，并且追踪有那些顶点还没有被访问到
    2. 有两种算法可以对图进行遍历：
        * 广度优先搜索（Breadth-First Search，简称 BFS）
        * 深度优先搜索（Depth-First Search，简称 DFS）
    3. 遍历的注意点：
        * 完全探索一个顶点要求我们便查看该顶点的每一条边
        * 对于每一条所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中
        * 为了保证算法的效率，每个顶点至多访问两次
    4. 两种算法的思想：
        * BFS：基于队列，入队列的顶点先被探索
        * DFS：基于栈，通过将栈顶存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问
        * 使用标志位位来反应状态
            * 白色：表示该顶点还没有被访问
            * 灰色：表示该顶点被访问过，但并未被探索过
            * 黑色：表示该顶点被访问过且被完全探索过
    * 广度优先算法会先从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层，就是先宽后深的访问顶点
    * 深度优先搜索思路：将会从第一个指定的顶点开始遍历图，沿着路径知道这条路径最后被访问了，接着原路回退并探索下一条路径




